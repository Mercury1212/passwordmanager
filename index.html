<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Password Manager</title>
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #166088;
            --accent: #4cb5f5;
            --danger: #e63946;
            --success: #2a9d8f;
            --warning: #f4a261;
            --light: #f8f9fa;
            --dark: #212529;
            --gray: #6c757d;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        [data-theme="dark"] {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #2d2d2d;
            --text-primary: #f0f0f0;
            --text-secondary: #cccccc;
            --border-color: #444;
        }

        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #e9e9e9;
            --text-primary: #212529;
            --text-secondary: #495057;
            --border-color: #dee2e6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: var(--transition);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 2rem;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition);
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--secondary);
        }

        .btn-danger {
            background-color: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background-color: #c1121f;
        }

        .btn-success {
            background-color: var(--success);
            color: white;
        }

        .btn-success:hover {
            background-color: #218f84;
        }

        .btn-warning {
            background-color: var(--warning);
            color: white;
        }

        .btn-warning:hover {
            background-color: #e76f51;
        }

        .btn-secondary {
            background-color: var(--gray);
            color: white;
        }

        .btn-secondary:hover {
            background-color: #5a6268;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--bg-primary);
            padding: 2rem;
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 500px;
            box-shadow: var(--box-shadow);
            transform: translateY(-20px);
            transition: transform 0.3s;
        }

        .modal.active .modal-content {
            transform: translateY(0);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            position: relative;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            position: absolute;
            top: -10px;
            right: -10px;
        }

        .form-group {
            margin-bottom: 1rem;
            position: relative;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }

        .toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .search-box {
            flex: 1;
            min-width: 250px;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 2.5rem 0.75rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }

        .search-icon {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }

        .entries-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        .entry-card {
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            box-shadow: var(--box-shadow);
            transition: var(--transition);
            border: 1px solid transparent;
        }

        .entry-card:hover {
            border-color: var(--accent);
            transform: translateY(-5px);
        }

        .entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }

        .entry-name {
            font-weight: 600;
            font-size: 1.25rem;
            margin-bottom: 0.25rem;
        }

        .entry-username {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .entry-actions {
            display: flex;
            gap: 0.5rem;
        }

        .action-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 1rem;
            padding: 0.25rem;
        }

        .action-btn:hover {
            color: var(--accent);
            background-color: var(--bg-tertiary);
            border-radius: 4px;
        }

        .password-field {
            position: relative;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
        }

        .password-input {
            width: 100%;
            padding: 0.5rem 4.5rem 0.5rem 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: monospace;
        }

        .toggle-password {
            position: absolute;
            right: 2.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 0.25rem;
        }

        .copy-password {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 0.25rem;
        }

        .entry-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .tag {
            background-color: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 1rem;
            font-size: 0.75rem;
        }

        .entry-footer {
            display: flex;
            justify-content: space-between;
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: var(--gray);
        }

        .theme-toggle {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 1.5rem;
        }

        .progress-bar {
            height: 4px;
            background-color: var(--accent);
            width: 0;
            transition: width 0.3s;
        }

        .notification {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            padding: 1rem;
            border-radius: var(--border-radius);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            box-shadow: var(--box-shadow);
            transform: translateY(100px);
            opacity: 0;
            transition: transform 0.3s, opacity 0.3s;
            z-index: 1000;
        }

        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }

        .notification.success {
            border-left: 4px solid var(--success);
        }

        .notification.error {
            border-left: 4px solid var(--danger);
        }

        .notification.warning {
            border-left: 4px solid var(--warning);
        }

        .copy-notification {
            position: absolute;
            top: -30px;
            right: 0;
            background: var(--dark);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .copy-notification.show {
            opacity: 1;
        }

        .confirmation-dialog {
            text-align: center;
        }

        .confirmation-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .password-settings {
            margin-top: 1rem;
            padding: 1rem;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
        }

        .password-settings.hidden {
            display: none;
        }

        .password-settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .password-settings-title {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .password-settings-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .password-settings-fullwidth {
            grid-column: 1 / -1;
        }

        .password-settings-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        /* TOTP Styles */
        .totp-field {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background-color: var(--bg-tertiary);
            border-radius: var(--border-radius);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .totp-code {
            font-family: monospace;
            font-size: 1.25rem;
            font-weight: bold;
            letter-spacing: 2px;
            min-width: 100px;
            text-align: center;
        }

        .totp-timer {
            flex: 1;
            height: 4px;
            background-color: var(--bg-secondary);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .totp-progress {
            height: 100%;
            background-color: var(--success);
            width: 100%;
            transition: width 1s linear;
        }

        .totp-copy {
            white-space: nowrap;
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
        }

        @media (max-width: 768px) {
            .entries-grid {
                grid-template-columns: 1fr;
            }
            
            .toolbar {
                flex-direction: column;
                align-items: stretch;
            }
            
            .search-box {
                min-width: 100%;
            }
            
            .confirmation-buttons {
                flex-direction: column;
            }
            
            .password-settings-content {
                grid-template-columns: 1fr;
            }
            
            .totp-field {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .totp-timer {
                width: 100%;
            }
        }

        .auto-save-indicator {
            display: inline-block;
            margin-left: 10px;
            font-size: 0.9rem;
            color: var(--success);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .auto-save-indicator.visible {
            opacity: 1;
        }
	.entry-url, .entry-email {
   	 margin: 0.25rem 0;
   	 font-size: 0.9rem;
   	 color: var(--text-secondary);
   	 word-break: break-all; /* prevents overflow for long URLs */
	}

	.entry-url a, .entry-email a {
   	 color: var(--accent);
   	 text-decoration: none;
	}

	.entry-url a:hover, .entry-email a:hover {
   	 text-decoration: underline;
	}
/* Copy button for URL/Email */
.copy-field {
    background: none;
    border: none;
    cursor: pointer;
    margin-left: 5px;
    font-size: 0.9rem;
    color: var(--text-secondary);
}

.copy-field:hover {
    color: var(--accent);
}


    </style>
    <!-- Add Argon2-browser script -->
    <script src="https://unpkg.com/argon2-browser@1.18.0/dist/argon2-bundled.min.js"></script>
    <!-- Add CryptoJS for TOTP functionality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body data-theme="light">
    <div class="container">
        <header>
            <div class="logo">🔒 SecurePass</div>
            <div>
                <button class="theme-toggle" id="themeToggle">🌙</button>
                <button class="btn btn-primary" id="lockBtn">Lock</button>
            </div>
        </header>

        <main id="mainContent">
            <!-- Welcome screen shown initially -->
            <div id="welcomeScreen" class="welcome-screen">
                <div class="empty-state">
                    <div class="empty-state-icon">🔒</div>
                    <h2>Secure Password Manager</h2>
                    <p>Your offline-first, secure password management solution</p>
                    <div style="margin-top: 2rem; display: flex; gap: 1rem; justify-content: center;">
                        <button class="btn btn-primary" id="createVaultBtn">Create New Vault</button>
                        <button class="btn btn-success" id="openVaultBtn">Open Existing Vault</button>
                    </div>
                </div>
            </div>

            <!-- Main app interface (hidden initially) -->
            <div id="appInterface" style="display: none;">
                <div class="toolbar">
                    <div class="search-box">
                        <input type="text" id="searchInput" class="search-input" placeholder="Search entries...">
                        <span class="search-icon">🔍</span>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-primary" id="addEntryBtn">Add Entry</button>
                        <div style="position: relative;">
                            <button class="btn btn-warning" id="importExportBtn">Import/Export</button>
                            <div class="dropdown-menu" id="importExportMenu" style="display: none; position: absolute; top: 100%; right: 0; background: var(--bg-secondary); border-radius: var(--border-radius); box-shadow: var(--box-shadow); padding: 0.5rem; min-width: 200px; z-index: 10;">
                                <button class="btn btn-secondary" style="width: 100%; text-align: left; margin-bottom: 0.25rem;" id="importCsvBtn">Import CSV</button>
                                <button class="btn btn-secondary" style="width: 100%; text-align: left; margin-bottom: 0.25rem;" id="importEncryptedCsvBtn">Import Encrypted CSV</button>
                                <button class="btn btn-secondary" style="width: 100%; text-align: left; margin-bottom: 0.25rem;" id="exportCsvBtn">Export CSV (Plaintext)</button>
                                <button class="btn btn-secondary" style="width: 100%; text-align: left;" id="exportEncryptedCsvBtn">Export Encrypted CSV</button>
                            </div>
                        </div>
                        <button class="btn btn-success" id="saveVaultBtn">Save Vault</button>
                        <span id="autoSaveIndicator" class="auto-save-indicator">Auto-saved</span>
                    </div>
                </div>

                <div id="entriesContainer" class="entries-grid">
                    <!-- Entries will be dynamically added here -->
                    <div class="empty-state">
                        <div class="empty-state-icon">🔍</div>
                        <h3>No passwords yet</h3>
                        <p>Add your first password entry to get started</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modals -->
    <div class="modal" id="createVaultModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Create New Vault</h2>
                <button class="close-btn" data-dismiss="modal">×</button>
            </div>
            <form id="createVaultForm">
                <div class="form-group">
                    <label class="form-label" for="masterPassword">Master Password</label>
                    <input type="password" id="masterPassword" class="form-input" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="confirmMasterPassword">Confirm Master Password</label>
                    <input type="password" id="confirmMasterPassword" class="form-input" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Encryption Settings (Advanced)</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                        <div>
                            <label class="form-label" for="argonTime">Time Cost</label>
                            <input type="number" id="argonTime" class="form-input" value="3" min="1">
                        </div>
                        <div>
                            <label class="form-label" for="argonMemory">Memory (MB)</label>
                            <input type="number" id="argonMemory" class="form-input" value="64" min="8">
                        </div>
                        <div>
                            <label class="form-label" for="argonParallelism">Parallelism</label>
                            <input type="number" id="argonParallelism" class="form-input" value="4" min="1">
                        </div>
                    </div>
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">Create Vault</button>
            </form>
        </div>
    </div>

    <div class="modal" id="openVaultModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Open Vault</h2>
                <button class="close-btn" data-dismiss="modal">×</button>
            </div>
            <form id="openVaultForm">
                <div class="form-group">
                    <label class="form-label" for="vaultFile">Vault File</label>
                    <input type="file" id="vaultFile" class="form-input" accept=".vault" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="openMasterPassword">Master Password</label>
                    <input type="password" id="openMasterPassword" class="form-input" required>
                </div>
                <div class="progress-bar-container" style="height: 4px; background-color: var(--bg-tertiary); border-radius: 2px; margin-bottom: 1rem; overflow: hidden;">
                    <div class="progress-bar" id="decryptProgressBar"></div>
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">Open Vault</button>
            </form>
        </div>
    </div>

    <div class="modal" id="entryModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="entryModalTitle">Add Entry</h2>
                <button class="close-btn" data-dismiss="modal">×</button>
            </div>
            <form id="entryForm">
                <input type="hidden" id="entryId">
                <div class="form-group">
                    <label class="form-label" for="entryName">Name</label>
                    <input type="text" id="entryName" class="form-input" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="entryUsername">Username</label>
                    <input type="text" id="entryUsername" class="form-input">
                </div>
		<!-- URL (optional) -->
		<div class="form-group">
  		<label class="form-label" for="entryUrl">URL (optional)</label>
  		<input type="url" id="entryUrl" class="form-input" placeholder="https://example.com">
		</div>

		<!-- Email (optional) -->
		<div class="form-group">
  		<label class="form-label" for="entryEmail">Email (optional)</label>
  		<input type="email" id="entryEmail" class="form-input" placeholder="name@example.com">
		</div>

                <div class="form-group">
                    <label class="form-label" for="entryPassword">Password</label>
                    <div class="password-field">
                        <input type="password" id="entryPassword" class="password-input" required>
                        <button type="button" class="toggle-password" id="toggleModalPassword">👁️</button>
                        <button type="button" class="copy-password" id="copyModalPassword">📋</button>
                    </div>
                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                        <button type="button" class="btn btn-secondary" id="passwordSettingsBtn">Password Settings</button>
                        <button type="button" class="btn btn-primary" id="generatePasswordBtn">Generate Password</button>
                    </div>
                </div>
                
                <!-- TOTP Secret Field -->
                <div class="form-group">
                    <label class="form-label" for="entryTotp">TOTP Secret (optional)</label>
                    <div class="password-field">
                        <input type="password" id="entryTotp" class="password-input" placeholder="JBSWY3DPEHPK3PXP">
                        <button type="button" class="toggle-password" id="toggleModalTotp">👁️</button>
                        <button type="button" class="copy-password" id="copyModalTotp">📋</button>
                    </div>
                </div>
                
                <!-- Password Settings Section -->
                <div class="password-settings hidden" id="passwordSettingsSection">
                    <div class="password-settings-header">
                        <div class="password-settings-title">Password Generation Settings</div>
                    </div>
                    <div class="password-settings-content">
                        <div class="form-group">
                            <label class="form-label" for="passwordLength">Length</label>
                            <input type="number" id="passwordLength" class="form-input" value="24" min="4" max="128">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Character Sets</label>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                <label><input type="checkbox" id="useUppercase" checked> Uppercase Letters (A-Z)</label>
                                <label><input type="checkbox" id="useLowercase" checked> Lowercase Letters (a-z)</label>
                                <label><input type="checkbox" id="useDigits" checked> Digits (0-9)</label>
                                <label><input type="checkbox" id="useSymbols" checked> Symbols (!@#$%^&* etc.)</label>
                            </div>
                        </div>
                        <div class="form-group password-settings-fullwidth">
                            <label class="form-label">Options</label>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                <label><input type="checkbox" id="excludeAmbiguous" checked> Exclude Ambiguous Characters (O0Il)</label>
                                <label><input type="checkbox" id="requireAllTypes" checked> Require at least one character from each selected set</label>
                            </div>
                        </div>
                        <div class="form-group password-settings-fullwidth">
                            <label class="form-label" for="excludeChars">Exclude Characters</label>
                            <input type="text" id="excludeChars" class="form-input" placeholder="!@#">
                        </div>
                    </div>
                    <div class="password-settings-actions">
                        <button type="button" class="btn btn-secondary" id="closePasswordSettings">Close Settings</button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="entryNotes">Notes</label>
                    <textarea id="entryNotes" class="form-input form-textarea"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label" for="entryTags">Tags (comma-separated)</label>
                    <input type="text" id="entryTags" class="form-input" placeholder="work, personal, important">
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">Save Entry</button>
            </form>
        </div>
    </div>

    <div class="modal" id="csvWarningModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Security Warning</h2>
                <button class="close-btn" data-dismiss="modal">×</button>
            </div>
            <div class="form-group">
                <p>You are about to export your passwords in plaintext CSV format.</p>
                <p style="color: var(--danger); font-weight: bold;">CSV files are NOT encrypted and can be read by anyone who accesses the file.</p>
                <p>Please ensure you store this file securely and delete it after use.</p>
            </div>
            <div class="form-group">
                <label><input type="checkbox" id="understandRisk"> I understand the risks and want to proceed</label>
            </div>
            <button type="button" class="btn btn-danger" id="confirmCsvExport" disabled style="width: 100%;">Export Anyway</button>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div class="modal" id="deleteConfirmationModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Confirm Deletion</h2>
                <button class="close-btn" data-dismiss="modal">×</button>
            </div>
            <div class="confirmation-dialog">
                <p>Are you sure you want to delete this entry?</p>
                <p><strong id="entryToDeleteName"></strong></p>
                <p class="text-warning">This action cannot be undone.</p>
                <div class="confirmation-buttons">
                    <button class="btn btn-secondary" id="cancelDelete">Cancel</button>
                    <button class="btn btn-danger" id="confirmDelete">Delete Entry</button>
                </div>
            </div>
        </div>
    </div>

    <div id="notification" class="notification"></div>

    <script>
        // Global state
        const state = {
            vault: {
                entries: [],
                argon2Params: {
                    time: 3,
                    memory: 64,
                    parallelism: 4
                }
            },
            derivedKey: null,
            masterPassword: null,
            isUnlocked: false,
            undoStack: [],
            entryToDelete: null,
            vaultFileHandle: null
        };

        // DOM Elements
        const elements = {
            welcomeScreen: document.getElementById('welcomeScreen'),
            appInterface: document.getElementById('appInterface'),
            entriesContainer: document.getElementById('entriesContainer'),
            createVaultBtn: document.getElementById('createVaultBtn'),
            openVaultBtn: document.getElementById('openVaultBtn'),
            lockBtn: document.getElementById('lockBtn'),
            addEntryBtn: document.getElementById('addEntryBtn'),
            importExportBtn: document.getElementById('importExportBtn'),
            importExportMenu: document.getElementById('importExportMenu'),
            importCsvBtn: document.getElementById('importCsvBtn'),
            importEncryptedCsvBtn: document.getElementById('importEncryptedCsvBtn'),
            exportCsvBtn: document.getElementById('exportCsvBtn'),
            exportEncryptedCsvBtn: document.getElementById('exportEncryptedCsvBtn'),
            saveVaultBtn: document.getElementById('saveVaultBtn'),
            searchInput: document.getElementById('searchInput'),
            themeToggle: document.getElementById('themeToggle'),
            autoSaveIndicator: document.getElementById('autoSaveIndicator'),
            
            // Modals
            modals: document.querySelectorAll('.modal'),
            createVaultModal: document.getElementById('createVaultModal'),
            openVaultModal: document.getElementById('openVaultModal'),
		importExportModal: document.getElementById('importExportModal'),
            entryModal: document.getElementById('entryModal'),
            csvWarningModal: document.getElementById('csvWarningModal'),
            deleteConfirmationModal: document.getElementById('deleteConfirmationModal'),
            
            // Forms
            createVaultForm: document.getElementById('createVaultForm'),
            openVaultForm: document.getElementById('openVaultForm'),
            entryForm: document.getElementById('entryForm'),
            
            // Notification
            notification: document.getElementById('notification'),
            
            // Delete confirmation elements
            entryToDeleteName: document.getElementById('entryToDeleteName'),
            cancelDelete: document.getElementById('cancelDelete'),
            confirmDelete: document.getElementById('confirmDelete'),
            
            // Password generation elements
            passwordSettingsBtn: document.getElementById('passwordSettingsBtn'),
            passwordSettingsSection: document.getElementById('passwordSettingsSection'),
            generatePasswordBtn: document.getElementById('generatePasswordBtn'),
            closePasswordSettings: document.getElementById('closePasswordSettings'),
            toggleModalPassword: document.getElementById('toggleModalPassword'),
            copyModalPassword: document.getElementById('copyModalPassword'),
            
            // TOTP elements
            toggleModalTotp: document.getElementById('toggleModalTotp'),
            copyModalTotp: document.getElementById('copyModalTotp')
        };

        // TOTP functionality
        const TOTP = {
            // Base32 alphabet
            base32Alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
            
            // Decode base32 string
            base32Decode: function(base32) {
                base32 = base32.replace(/=+$/, '').toUpperCase();
                let bits = '';
                let output = '';
                
                for (let i = 0; i < base32.length; i++) {
                    const val = this.base32Alphabet.indexOf(base32[i]);
                    if (val === -1) continue;
                    bits += val.toString(2).padStart(5, '0');
                }
                
                for (let i = 0; i + 8 <= bits.length; i += 8) {
                    const chunk = bits.substr(i, 8);
                    output += String.fromCharCode(parseInt(chunk, 2));
                }
                
                return output;
            },
            
            // Generate TOTP code
            generate: function(secret, period = 30, digits = 6) {
                try {
                    // Decode the base32 secret
                    const key = this.base32Decode(secret.replace(/\s/g, ''));
                    
                    // Get current time counter
                    const time = Math.floor(Date.now() / 1000 / period);
                    
                    // Convert time to byte array
                    const timeBuffer = new ArrayBuffer(8);
                    const timeView = new DataView(timeBuffer);
                    timeView.setUint32(4, time, false); // Big-endian
                    
                    // Create HMAC-SHA1
                    const cryptoKey = this.stringToKey(key);
                    const hmac = CryptoJS.HmacSHA1(CryptoJS.enc.Latin1.parse(this.arrayBufferToString(timeBuffer)), cryptoKey);
                    const hmacResult = hmac.toString(CryptoJS.enc.Hex);
                    
                    // Get offset and dynamic binary code
                    const offset = parseInt(hmacResult.substr(hmacResult.length - 1), 16) * 2;
                    const binaryCode = parseInt(hmacResult.substr(offset, 8), 16) & 0x7fffffff;
                    
                    // Generate the OTP code
                    const otp = binaryCode % Math.pow(10, digits);
                    return otp.toString().padStart(digits, '0');
                } catch (error) {
                    console.error('TOTP generation error:', error);
                    return null;
                }
            },
            
            // Convert string to CryptoJS key
            stringToKey: function(key) {
                return CryptoJS.enc.Latin1.parse(key);
            },
            
            // Convert ArrayBuffer to string
            arrayBufferToString: function(buffer) {
                return String.fromCharCode.apply(null, new Uint8Array(buffer));
            },
            
            // Get time remaining until next code
            getTimeRemaining: function(period = 30) {
                const now = Date.now() / 1000;
                return period - (now % period);
            },
            
            // Update TOTP displays
            updateTotpDisplays: function() {
                if (!state.isUnlocked) return;
                
                document.querySelectorAll('.entry-card').forEach(card => {
                    const entryId = card.dataset.id;
                    const entry = state.vault.entries.find(e => e.id === entryId);
                    
                    if (!entry || !entry.totpSecret) {
                        const totpField = card.querySelector('.totp-field');
                        if (totpField) totpField.style.display = 'none';
                        return;
                    }
                    
                    const totpField = card.querySelector('.totp-field');
                    if (!totpField) return;
                    
                    totpField.style.display = 'flex';
                    
                    // Generate TOTP code
                    const code = this.generate(entry.totpSecret);
                    const timeRemaining = this.getTimeRemaining();
                    const progressPercent = (timeRemaining / 30) * 100;
                    
                    if (code) {
                        const codeElement = totpField.querySelector('.totp-code');
                        const progressElement = totpField.querySelector('.totp-progress');
                        
                        if (codeElement) codeElement.textContent = code;
                        if (progressElement) progressElement.style.width = `${progressPercent}%`;
                        
                        // Change color based on time remaining
                        if (timeRemaining < 10) {
                            progressElement.style.backgroundColor = 'var(--danger)';
                        } else if (timeRemaining < 20) {
                            progressElement.style.backgroundColor = 'var(--warning)';
                        } else {
                            progressElement.style.backgroundColor = 'var(--success)';
                        }
                    }
                });
            },
            
            // Initialize TOTP timer
            init: function() {
                // Update TOTP displays immediately
                this.updateTotpDisplays();
                
                // Update every second
                setInterval(() => {
                    this.updateTotpDisplays();
                }, 1000);
            },
            
            // Copy TOTP code to clipboard
            copyTotpCode: function(entryId) {
                const entry = state.vault.entries.find(e => e.id === entryId);
                if (!entry || !entry.totpSecret) return;
                
                const code = this.generate(entry.totpSecret);
                if (!code) return;
                
                navigator.clipboard.writeText(code)
                    .then(() => {
                        showNotification('TOTP code copied to clipboard', 'success');
                    })
                    .catch(err => {
                        console.error('Failed to copy TOTP code:', err);
                        showNotification('Failed to copy TOTP code', 'error');
                    });
            },
            
            // Toggle TOTP visibility in modal
            toggleModalTotpVisibility: function() {
                const totpInput = document.getElementById('entryTotp');
                if (totpInput.type === 'password') {
                    totpInput.type = 'text';
                    elements.toggleModalTotp.textContent = '🙈';
                } else {
                    totpInput.type = 'password';
                    elements.toggleModalTotp.textContent = '👁️';
                }
            },
            
            // Copy TOTP from modal
            copyModalTotp: function() {
                const totpInput = document.getElementById('entryTotp');
                navigator.clipboard.writeText(totpInput.value)
                    .then(() => {
                        showNotification('TOTP secret copied to clipboard', 'success');
                    })
                    .catch(err => {
                        console.error('Failed to copy TOTP secret:', err);
                        showNotification('Failed to copy TOTP secret', 'error');
                    });
            }
        };

        // Initialize the application
        function init() {
            setupEventListeners();
            checkSystemRequirements();
            loadThemePreference();
            TOTP.init(); // Initialize TOTP functionality
        }

        // Set up event listeners
        function setupEventListeners() {
            // Navigation buttons
            elements.createVaultBtn.addEventListener('click', () => showModal(elements.createVaultModal));
            elements.openVaultBtn.addEventListener('click', () => showModal(elements.openVaultModal));
            elements.lockBtn.addEventListener('click', lockVault);
            elements.addEntryBtn.addEventListener('click', () => showAddEntryModal());
            elements.importExportBtn.addEventListener('click', toggleImportExportMenu);
            elements.importCsvBtn.addEventListener('click', () => importCsv());
            elements.importEncryptedCsvBtn.addEventListener('click', () => importEncryptedCsv());
            elements.exportCsvBtn.addEventListener('click', () => showModal(elements.csvWarningModal));
            elements.exportEncryptedCsvBtn.addEventListener('click', () => exportEncryptedCsv());
            elements.saveVaultBtn.addEventListener('click', saveVaultToFile);
            elements.searchInput.addEventListener('input', filterEntries);
            elements.themeToggle.addEventListener('click', toggleTheme);
            
			// Close Import/Export menu when clicking outside
			document.addEventListener('click', (e) => {
			    if (
		     	   !elements.importExportBtn.contains(e.target) && 
		      	  !elements.importExportMenu.contains(e.target)
		  	  ) {
 		    	   elements.importExportMenu.style.display = 'none';
 			   }
			});


            // Password generation and settings
            elements.passwordSettingsBtn.addEventListener('click', togglePasswordSettings);
            elements.generatePasswordBtn.addEventListener('click', generatePasswordForEntry);
            elements.closePasswordSettings.addEventListener('click', togglePasswordSettings);
            elements.toggleModalPassword.addEventListener('click', toggleModalPasswordVisibility);
            elements.copyModalPassword.addEventListener('click', copyModalPassword);
            
            // TOTP event listeners
            elements.toggleModalTotp.addEventListener('click', TOTP.toggleModalTotpVisibility);
            elements.copyModalTotp.addEventListener('click', TOTP.copyModalTotp);
            
            // Modal dismiss buttons
            document.querySelectorAll('.close-btn, [data-dismiss="modal"]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const modal = e.target.closest('.modal');
                    hideModal(modal);
                });
            });
            
            // Click outside modal to close
            elements.modals.forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        hideModal(modal);
                    }
                });
            });
            
            // Form submissions
            elements.createVaultForm.addEventListener('submit', createVault);
            elements.openVaultForm.addEventListener('submit', openVault);
            elements.entryForm.addEventListener('submit', saveEntry);
            
            // CSV warning
            document.getElementById('understandRisk').addEventListener('change', (e) => {
                document.getElementById('confirmCsvExport').disabled = !e.target.checked;
            });
            
            document.getElementById('confirmCsvExport').addEventListener('click', exportCsvPlain);
            
            // Delete confirmation
            elements.cancelDelete.addEventListener('click', () => hideModal(elements.deleteConfirmationModal));
            elements.confirmDelete.addEventListener('click', confirmDeleteEntry);
            
            // Event delegation for entry actions
            elements.entriesContainer.addEventListener('click', handleEntryActionClick);
        }

        // Handle entry action clicks using event delegation
function handleEntryActionClick(e) {
    if (!state.isUnlocked) {
        showNotification('Vault is locked', 'error');
        return;
    }
    
    const target = e.target;
    const entryCard = target.closest('.entry-card');
    
    if (!entryCard) return;
    
    const entryId = entryCard.dataset.id;
    
    if (!entryId) return;
    
    // Handle edit button
    if (target.classList.contains('action-btn') && target.textContent.includes('✏️')) {
        editEntry(entryId);
    }
    // Handle duplicate button
    else if (target.classList.contains('action-btn') && target.textContent.includes('📋')) {
        duplicateEntry(entryId);
    }
    // Handle delete button
    else if (target.classList.contains('action-btn') && target.textContent.includes('🗑️')) {
        deleteEntry(entryId);
    }
    // ✅ Handle copy URL/Email
    else if (target.classList.contains('copy-field')) {
        const value = target.dataset.copy;
        if (value) {
            navigator.clipboard.writeText(value).then(() => {
                showNotification('Copied: ' + value, 'success');
            }).catch(err => {
                console.error('Failed to copy', err);
                showNotification('Failed to copy', 'error');
            });
        }
    }
            // Handle password visibility toggle
            else if (target.classList.contains('toggle-password')) {
                togglePasswordVisibility(entryId);
            }
            // Handle copy password button
            else if (target.classList.contains('copy-password')) {
                copyPasswordToClipboard(entryId);
            }
            // Handle TOTP copy button
            else if (target.classList.contains('totp-copy')) {
                TOTP.copyTotpCode(entryId);
            }
        }

        // Check if the browser supports required APIs
        function checkSystemRequirements() {
            if (!window.crypto || !window.crypto.subtle) {
                showNotification('Your browser does not support Web Cryptography API. Please use a modern browser.', 'error');
            }
            
            if (typeof WebAssembly !== 'object' || !WebAssembly.instantiate) {
                showNotification('WebAssembly is not supported in your browser. Argon2 will not work.', 'error');
            }
            
            // Check if Argon2 is available
            if (typeof argon2 === 'undefined') {
                showNotification('Argon2 library failed to load. Please check your internet connection.', 'error');
            }
        }

        // Theme management
        function loadThemePreference() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.body.setAttribute('data-theme', savedTheme);
            elements.themeToggle.textContent = savedTheme === 'light' ? '🌙' : '☀️';
        }

        function toggleTheme() {
            const currentTheme = document.body.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.body.setAttribute('data-theme', newTheme);
            elements.themeToggle.textContent = newTheme === 'light' ? '🌙' : '☀️';
            localStorage.setItem('theme', newTheme);
        }

        // Modal management
        function showModal(modal) {
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function hideModal(modal) {
            modal.classList.remove('active');
            document.body.style.overflow = 'auto';
            
            // Reset forms when hiding
            if (modal === elements.entryModal) {
                elements.entryForm.reset();
                document.getElementById('entryId').value = '';
                elements.passwordSettingsSection.classList.add('hidden');
            }
            
            if (modal === elements.csvWarningModal) {
                document.getElementById('understandRisk').checked = false;
                document.getElementById('confirmCsvExport').disabled = true;
            }
            
            if (modal === elements.deleteConfirmationModal) {
                state.entryToDelete = null;
            }
        }

        function toggleImportExportMenu() {
            elements.importExportMenu.style.display = 
                elements.importExportMenu.style.display === 'none' ? 'block' : 'none';
        }

        // Password settings toggle
        function togglePasswordSettings() {
            elements.passwordSettingsSection.classList.toggle('hidden');
        }

        // Notification system
        function showNotification(message, type = 'info') {
            const notification = elements.notification;
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Show auto-save indicator
        function showAutoSaveIndicator() {
            elements.autoSaveIndicator.classList.add('visible');
            setTimeout(() => {
                elements.autoSaveIndicator.classList.remove('visible');
            }, 2000);
        }

        // Vault management
        async function createVault(e) {
            e.preventDefault();
            
            const masterPassword = document.getElementById('masterPassword').value;
            const confirmPassword = document.getElementById('confirmMasterPassword').value;
            
            if (masterPassword !== confirmPassword) {
                showNotification('Passwords do not match', 'error');
                return;
            }
            
            if (masterPassword.length < 8) {
                showNotification('Master password must be at least 8 characters', 'error');
                return;
            }
            
            // Get Argon2 parameters
            state.vault.argon2Params = {
                time: parseInt(document.getElementById('argonTime').value) || 3,
                memory: parseInt(document.getElementById('argonMemory').value) || 64,
                parallelism: parseInt(document.getElementById('argonParallelism').value) || 4
            };
            
            state.masterPassword = masterPassword;
            state.isUnlocked = true;
            
            // Initialize vault with empty entries
            state.vault.entries = [];
            
            // Show main interface
            elements.welcomeScreen.style.display = 'none';
            elements.appInterface.style.display = 'block';
            
            // Render empty state
            renderEntries();
            
            hideModal(elements.createVaultModal);
            showNotification('Vault created successfully', 'success');
            
            // Save vault to file immediately after creation
            try {
                await saveVaultToFile();
                showNotification('Vault saved successfully', 'success');
            } catch (error) {
                console.error('Failed to save vault:', error);
                showNotification('Failed to save vault. Please save manually.', 'error');
            }
        }

        async function openVault(e) {
            e.preventDefault();
            
            const fileInput = document.getElementById('vaultFile');
            const masterPassword = document.getElementById('openMasterPassword').value;
            
            if (!fileInput.files.length) {
                showNotification('Please select a vault file', 'error');
                return;
            }
            
            if (masterPassword.length < 8) {
                showNotification('Master password must be at least 8 characters', 'error');
                return;
            }
            
            const file = fileInput.files[0];
            const reader = new FileReader();
            
            reader.onload = async (event) => {
                try {
                    // Show progress bar
                    const progressBar = document.getElementById('decryptProgressBar');
                    
                    // Decrypt the vault
                    const arrayBuffer = event.target.result;
                    const decryptedData = await decryptVault(arrayBuffer, masterPassword, (progress) => {
                        progressBar.style.width = `${progress * 100}%`;
                    });
                    
                    // Parse the decrypted JSON
                    const vault = JSON.parse(decryptedData);
                    
                    // Update state
                    state.vault = vault;
                    state.masterPassword = masterPassword;
                    state.isUnlocked = true;
                    
                    // Show main interface
                    elements.welcomeScreen.style.display = 'none';
                    elements.appInterface.style.display = 'block';
                    
                    // Render entries
                    renderEntries();
                    
                    hideModal(elements.openVaultModal);
                    showNotification('Vault unlocked successfully', 'success');
                } catch (error) {
                    console.error('Failed to open vault:', error);
                    showNotification('Failed to open vault. Wrong password or corrupted file.', 'error');
                }
            };
            
            reader.readAsArrayBuffer(file);
        }

        function lockVault() {
            state.isUnlocked = false;
            state.derivedKey = null;
            state.masterPassword = null;
            state.vaultFileHandle = null;
            
            // Clear entries from display
            elements.entriesContainer.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">🔒</div>
                    <h3>Vault is locked</h3>
                    <p>Unlock your vault to access your passwords</p>
                </div>
            `;
            
            // Show welcome screen
            elements.welcomeScreen.style.display = 'block';
            elements.appInterface.style.display = 'none';
            
            showNotification('Vault locked', 'info');
        }

        async function saveVaultToFile() {
            if (!state.isUnlocked) {
                showNotification('Vault is locked', 'error');
                return;
            }
            
            try {
                // Encrypt the vault
                const encryptedData = await encryptVault(JSON.stringify(state.vault), state.masterPassword);
                
                // Create a blob
                const blob = new Blob([encryptedData], { type: 'application/octet-stream' });
                
                // Try to use the File System Access API if available
                if (window.showSaveFilePicker && !state.vaultFileHandle) {
                    try {
                        state.vaultFileHandle = await window.showSaveFilePicker({
                            suggestedName: `passman-vault-${new Date().toISOString().slice(0, 10)}.vault`,
                            types: [{
                                description: 'SecurePass Vault',
                                accept: {'application/octet-stream': ['.vault']},
                            }],
                        });
                    } catch (e) {
                        console.warn('File System Access API not available:', e);
                    }
                }
                
                // If we have a file handle, write to it
                if (state.vaultFileHandle) {
                    const writable = await state.vaultFileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    showAutoSaveIndicator();
                    showNotification('Vault saved successfully', 'success');
                    return;
                }
                
                // Fallback: download the file
                const url = URL.createObjectURL(blob);
                
                // Create download link
                const a = document.createElement('a');
                a.href = url;
                a.download = `passman-vault-${new Date().toISOString().slice(0, 10)}.vault`;
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
                showNotification('Vault saved successfully', 'success');
            } catch (error) {
                console.error('Failed to save vault:', error);
                showNotification('Failed to save vault', 'error');
                throw error;
            }
        }

        // Auto-save function
        async function autoSaveVault() {
            if (!state.isUnlocked || !state.vaultFileHandle) {
                return;
            }
            
            try {
                await saveVaultToFile();
                showAutoSaveIndicator();
            } catch (error) {
                console.error('Auto-save failed:', error);
            }
        }

        // Entry management
        function showAddEntryModal() {
            if (!state.isUnlocked) {
                showNotification('Vault is locked', 'error');
                return;
            }
            
            document.getElementById('entryModalTitle').textContent = 'Add Entry';
            showModal(elements.entryModal);
        }

        async function saveEntry(e) {
            e.preventDefault();
            
            if (!state.isUnlocked) {
                showNotification('Vault is locked', 'error');
                return;
            }
            
            const entryId = document.getElementById('entryId').value;
            const name = document.getElementById('entryName').value;
            const username = document.getElementById('entryUsername').value;
		const url = document.getElementById('entryUrl').value;          // NEW
		const email = document.getElementById('entryEmail').value;      // NEW
            const password = document.getElementById('entryPassword').value;
            const totpSecret = document.getElementById('entryTotp').value;
            const notes = document.getElementById('entryNotes').value;
            const tags = document.getElementById('entryTags').value.split(',').map(tag => tag.trim()).filter(tag => tag);
            
            const entry = {
                id: entryId || Date.now().toString(),
                name,
                username,
		url: url || '',
		email: email || '',
                password,
                totpSecret: totpSecret || null, // Add TOTP secret
                notes,
                tags,
                createdAt: entryId ? state.vault.entries.find(e => e.id === entryId)?.createdAt || Date.now() : Date.now(),
                updatedAt: Date.now()
            };
            
            if (entryId) {
                // Update existing entry
                const index = state.vault.entries.findIndex(e => e.id === entryId);
                if (index !== -1) {
                    state.vault.entries[index] = entry;
                }
            } else {
                // Add new entry
                state.vault.entries.push(entry);
            }
            
            // Save to undo stack
            state.undoStack.push(JSON.parse(JSON.stringify(state.vault.entries)));
            
            // Render entries
            renderEntries();
            
            hideModal(elements.entryModal);
            showNotification(`Entry ${entryId ? 'updated' : 'added'} successfully`, 'success');
            
            // Auto-save the vault
            await autoSaveVault();
        }

        async function editEntry(entryId) {
            if (!state.isUnlocked) {
                showNotification('Vault is locked', 'error');
                return;
            }
            
            const entry = state.vault.entries.find(e => e.id === entryId);
            if (!entry) return;
            
            // Fill the form with entry data
            document.getElementById('entryModalTitle').textContent = 'Edit Entry';
            document.getElementById('entryId').value = entry.id;
            document.getElementById('entryName').value = entry.name;
            document.getElementById('entryUsername').value = entry.username || '';
		document.getElementById('entryUrl').value = entry.url || '';        // NEW
		document.getElementById('entryEmail').value = entry.email || '';    // NEW
            document.getElementById('entryPassword').value = entry.password;
            document.getElementById('entryTotp').value = entry.totpSecret || '';
            document.getElementById('entryNotes').value = entry.notes || '';
            document.getElementById('entryTags').value = entry.tags.join(', ');
            
            showModal(elements.entryModal);
        }

        async function duplicateEntry(entryId) {
            if (!state.isUnlocked) {
                showNotification('Vault is locked', 'error');
                return;
            }
            
            const entry = state.vault.entries.find(e => e.id === entryId);
            if (!entry) return;
            
            // Create a copy with a new ID
            const newEntry = JSON.parse(JSON.stringify(entry));
            newEntry.id = Date.now().toString();
            newEntry.name = `${entry.name} (Copy)`;
            newEntry.createdAt = Date.now();
            newEntry.updatedAt = Date.now();
            
            // Add to entries
            state.vault.entries.push(newEntry);
            
            // Save to undo stack
            state.undoStack.push(JSON.parse(JSON.stringify(state.vault.entries)));
            
            // Render entries
            renderEntries();
            
            showNotification('Entry duplicated successfully', 'success');
            
            // Auto-save the vault
            await autoSaveVault();
        }

        function deleteEntry(entryId) {
            if (!state.isUnlocked) {
                showNotification('Vault is locked', 'error');
                return;
            }
            
            const entry = state.vault.entries.find(e => e.id === entryId);
            if (!entry) return;
            
            // Store entry to delete
            state.entryToDelete = entryId;
            
            // Show confirmation modal
            elements.entryToDeleteName.textContent = entry.name;
            showModal(elements.deleteConfirmationModal);
        }

        async function confirmDeleteEntry() {
            if (!state.entryToDelete) return;
            
            // Save to undo stack
            state.undoStack.push(JSON.parse(JSON.stringify(state.vault.entries)));
            
            // Remove the entry
            state.vault.entries = state.vault.entries.filter(e => e.id !== state.entryToDelete);
            
            // Render entries
            renderEntries();
            
            hideModal(elements.deleteConfirmationModal);
            showNotification('Entry deleted successfully', 'success');
            
            // Auto-save the vault
            await autoSaveVault();
        }

        function filterEntries() {
            const searchTerm = elements.searchInput.value.toLowerCase();
            
            if (!searchTerm) {
                // Show all entries if search is empty
                document.querySelectorAll('.entry-card').forEach(card => {
                    card.style.display = 'block';
                });
                return;
            }
            
            // Filter entries
            document.querySelectorAll('.entry-card').forEach(card => {
                const name = card.querySelector('.entry-name').textContent.toLowerCase();
                const username = card.querySelector('.entry-username').textContent.toLowerCase();
                const tags = Array.from(card.querySelectorAll('.tag')).map(tag => tag.textContent.toLowerCase());
                
                if (name.includes(searchTerm) || 
                    username.includes(searchTerm) || 
                    tags.some(tag => tag.includes(searchTerm))) {
                    card.style.display = 'block';
                } else {
                    card.style.display = 'none';
                }
            });
        }

        function renderEntries() {
            if (!state.vault.entries.length) {
                elements.entriesContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">🔍</div>
                        <h3>No passwords yet</h3>
                        <p>Add your first password entry to get started</p>
                    </div>
                `;
                return;
            }
            
            // Sort entries by name
            const sortedEntries = [...state.vault.entries].sort((a, b) => 
                a.name.localeCompare(b.name)
            );
            
            // Clear container
            elements.entriesContainer.innerHTML = '';
            
            // Render each entry
            sortedEntries.forEach(entry => {
                const entryElement = document.createElement('div');
                entryElement.className = 'entry-card';
                entryElement.dataset.id = entry.id;
                entryElement.innerHTML = `
                    <div class="entry-header">
                        <div>
                            <div class="entry-name">${escapeHtml(entry.name)}</div>
                            <div class="entry-username">${escapeHtml(entry.username || 'No username')}</div>
                        </div>
                        <div class="entry-actions">
                            <button class="action-btn" title="Edit">✏️</button>
                            <button class="action-btn" title="Duplicate">📋</button>
                            <button class="action-btn" title="Delete">🗑️</button>
                        </div>
                    </div>
                    <div class="password-field">
                        <input type="password" id="password-${entry.id}" class="password-input" value="${escapeHtml(entry.password)}" readonly>
                        <button class="toggle-password" data-entry="${entry.id}">👁️</button>
                        <button class="copy-password" data-entry="${entry.id}">📋</button>
                    </div>
			<!-- NEW: Show URL if available -->
    ${entry.url ? `
    <div class="entry-url">
        🌐 <a href="${escapeHtml(entry.url)}" target="_blank">${escapeHtml(entry.url)}</a>
        <button class="copy-field" data-copy="${escapeHtml(entry.url)}" title="Copy URL">📋</button>
    </div>
` : ''}

${entry.email ? `
    <div class="entry-email">
        📧 <a href="mailto:${escapeHtml(entry.email)}">${escapeHtml(entry.email)}</a>
        <button class="copy-field" data-copy="${escapeHtml(entry.email)}" title="Copy Email">📋</button>
    </div>
` : ''}

                    ${entry.totpSecret ? `
                        <div class="totp-field" id="totp-${entry.id}">
                            <div class="totp-code">••••••</div>
                            <div class="totp-timer">
                                <div class="totp-progress"></div>
                            </div>
                            <button class="btn btn-secondary totp-copy" data-entry="${entry.id}">Copy TOTP</button>
                        </div>
                    ` : ''}
                    ${entry.tags.length ? `
                        <div class="entry-tags">
                            ${entry.tags.map(tag => `<span class="tag">${escapeHtml(tag)}</span>`).join('')}
                        </div>
                    ` : ''}
                    <div class="entry-footer">
                        <div>Created: ${new Date(entry.createdAt).toLocaleDateString()}</div>
                        <div>Updated: ${new Date(entry.updatedAt).toLocaleDateString()}</div>
                    </div>
                `;
                
                elements.entriesContainer.appendChild(entryElement);
            });
            
            // Initialize TOTP displays
            TOTP.updateTotpDisplays();
        }

        // Password utilities
        function togglePasswordVisibility(entryId) {
            const passwordInput = document.getElementById(`password-${entryId}`);
            if (passwordInput.type === 'password') {
                passwordInput.type = 'text';
            } else {
                passwordInput.type = 'password';
            }
        }

        function toggleModalPasswordVisibility() {
            const passwordInput = document.getElementById('entryPassword');
            if (passwordInput.type === 'password') {
                passwordInput.type = 'text';
                elements.toggleModalPassword.textContent = '🙈';
            } else {
                passwordInput.type = 'password';
                elements.toggleModalPassword.textContent = '👁️';
            }
        }

        function copyPasswordToClipboard(entryId) {
            const entry = state.vault.entries.find(e => e.id === entryId);
            if (!entry) return;
            
            navigator.clipboard.writeText(entry.password)
                .then(() => {
                    showNotification('Password copied to clipboard', 'success');
                })
                .catch(err => {
                    console.error('Failed to copy password:', err);
                    showNotification('Failed to copy password', 'error');
                });
        }

        function copyModalPassword() {
            const passwordInput = document.getElementById('entryPassword');
            navigator.clipboard.writeText(passwordInput.value)
                .then(() => {
                    showNotification('Password copied to clipboard', 'success');
                })
                .catch(err => {
                    console.error('Failed to copy password:', err);
                    showNotification('Failed to copy password', 'error');
                });
        }

        function generatePasswordForEntry() {
            const length = parseInt(document.getElementById('passwordLength').value) || 24;
            const useUppercase = document.getElementById('useUppercase').checked;
            const useLowercase = document.getElementById('useLowercase').checked;
            const useDigits = document.getElementById('useDigits').checked;
            const useSymbols = document.getElementById('useSymbols').checked;
            const excludeAmbiguous = document.getElementById('excludeAmbiguous').checked;
            const requireAllTypes = document.getElementById('requireAllTypes').checked;
            const excludeChars = document.getElementById('excludeChars').value;
            
            const password = generatePassword(
                length,
                useUppercase,
                useLowercase,
                useDigits,
                useSymbols,
                excludeAmbiguous,
                requireAllTypes,
                excludeChars
            );
            
            document.getElementById('entryPassword').value = password;
        }

        function generatePassword(
            length = 24,
            useUppercase = true,
            useLowercase = true,
            useDigits = true,
            useSymbols = true,
            excludeAmbiguous = true,
            requireAllTypes = true,
            excludeChars = ''
        ) {
            // Character sets
            const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const lowercase = 'abcdefghijklmnopqrstuvwxyz';
            const digits = '0123456789';
            const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';
            
            // Ambiguous characters to exclude if requested
            const ambiguous = 'O0Il';
            
            // Build character pool based on options
            let charPool = '';
            if (useUppercase) charPool += uppercase;
            if (useLowercase) charPool += lowercase;
            if (useDigits) charPool += digits;
            if (useSymbols) charPool += symbols;
            
            // Remove excluded characters
            if (excludeAmbiguous) {
                for (const char of ambiguous) {
                    charPool = charPool.replace(char, '');
                }
            }
            
            // Remove user-specified excluded characters
            if (excludeChars) {
                for (const char of excludeChars) {
                    charPool = charPool.replace(char, '');
                }
            }
            
            // Ensure at least one character set is selected
            if (!charPool) {
                throw new Error('No character sets selected for password generation');
            }
            
            let password = '';
            const poolLength = charPool.length;
            
            // Generate password
            for (let i = 0; i < length; i++) {
                const randomIndex = Math.floor(Math.random() * poolLength);
                password += charPool[randomIndex];
            }
            
            // If required, ensure at least one character from each selected set
            if (requireAllTypes) {
                const sets = [];
                if (useUppercase) sets.push(uppercase);
                if (useLowercase) sets.push(lowercase);
                if (useDigits) sets.push(digits);
                if (useSymbols) sets.push(symbols);
                
                // Remove excluded characters from each set
                for (let i = 0; i < sets.length; i++) {
                    let set = sets[i];
                    if (excludeAmbiguous) {
                        for (const char of ambiguous) {
                            set = set.replace(char, '');
                        }
                    }
                    if (excludeChars) {
                        for (const char of excludeChars) {
                            set = set.replace(char, '');
                        }
                    }
                    sets[i] = set;
                }
                
                // Check if we have at least one character from each set
                const hasAllTypes = sets.every(set => {
                    for (const char of password) {
                        if (set.includes(char)) return true;
                    }
                    return false;
                });
                
                // If not, regenerate until we do
                if (!hasAllTypes) {
                    return generatePassword(
                        length,
                        useUppercase,
                        useLowercase,
                        useDigits,
                        useSymbols,
                        excludeAmbiguous,
                        requireAllTypes,
                        excludeChars
                    );
                }
            }
            
            return password;
        }

        // Import/Export functions
   	function importCsv() {
    if (!state.isUnlocked) {
        showNotification('Vault is locked', 'error');
        return;
    }
    
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.csv';
    
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const csvText = event.target.result;
                
                // === ADD DEBUG CODE HERE ===
                console.log('Raw CSV:', csvText);
                
                const entries = parseCsv(csvText);
                console.log('All parsed entries:', entries);
                
                // Check if specific fields are imported correctly
                entries.forEach((entry, index) => {
                    console.log(`Entry ${index}:`, {
                        name: entry.name,
                        url: entry.url,
                        email: entry.email,
                        notes: entry.notes,
                        tags: entry.tags
                    });
                });
                // === END DEBUG CODE ===
                
                // Add imported entries to vault
                state.vault.entries = [...state.vault.entries, ...entries];
                
                // Save to undo stack
                state.undoStack.push(JSON.parse(JSON.stringify(state.vault.entries)));
                
                // Render entries
                renderEntries();
                
                showNotification(`Imported ${entries.length} entries from CSV`, 'success');
                
                // Auto-save the vault
                autoSaveVault();
            } catch (error) {
                console.error('Failed to import CSV:', error);
                showNotification('Failed to import CSV. Invalid format.', 'error');
            }
        };
        
        reader.readAsText(file);
    };
    
    input.click();
}

        function exportCsvPlain() {
            if (!state.isUnlocked) {
                showNotification('Vault is locked', 'error');
                return;
            }
            
            // Generate CSV content
            const csvContent = generateCsv(state.vault.entries);
            
            // Create blob and download link
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            // Create download link
            const a = document.createElement('a');
            a.href = url;
            a.download = `passman-export-${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            hideModal(elements.csvWarningModal);
            showNotification('CSV exported successfully', 'success');
        }

        async function exportEncryptedCsv() {
            if (!state.isUnlocked) {
                showNotification('Vault is locked', 'error');
                return;
            }
            
            try {
                // Generate CSV content
                const csvContent = generateCsv(state.vault.entries);
                
                // Convert to ArrayBuffer
                const encoder = new TextEncoder();
                const csvData = encoder.encode(csvContent);
                
                // Generate salt and IV
                const salt = window.crypto.getRandomValues(new Uint8Array(16));
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                
                // Derive key using Argon2id
                const key = await deriveKeyArgon2(
                    state.masterPassword, 
                    salt, 
                    state.vault.argon2Params.time, 
                    state.vault.argon2Params.memory, 
                    state.vault.argon2Params.parallelism
                );
                
                // Encrypt the data
                const encryptedData = await window.crypto.subtle.encrypt(
                    {
                        name: "AES-GCM",
                        iv: iv
                    },
                    key,
                    csvData
                );
                
                // Create the file format: [salt][iv][time][memory][parallelism][ciphertext]
                const timeBytes = new Uint32Array([state.vault.argon2Params.time]);
                const memoryBytes = new Uint32Array([state.vault.argon2Params.memory]);
                const parallelismBytes = new Uint32Array([state.vault.argon2Params.parallelism]);
                
                const result = new Uint8Array(
                    salt.length + 
                    iv.length + 
                    timeBytes.byteLength + 
                    memoryBytes.byteLength + 
                    parallelismBytes.byteLength + 
                    encryptedData.byteLength
                );
                
                let offset = 0;
                result.set(salt, offset);
                offset += salt.length;
                result.set(iv, offset);
                offset += iv.length;
                result.set(new Uint8Array(timeBytes.buffer), offset);
                offset += timeBytes.byteLength;
                result.set(new Uint8Array(memoryBytes.buffer), offset);
                offset += memoryBytes.byteLength;
                result.set(new Uint8Array(parallelismBytes.buffer), offset);
                offset += parallelismBytes.byteLength;
                result.set(new Uint8Array(encryptedData), offset);
                
                // Create blob and download link
                const blob = new Blob([result], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                
                // Create download link
                const a = document.createElement('a');
                a.href = url;
                a.download = `passman-encrypted-${new Date().toISOString().slice(0, 10)}.vault`;
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
                showNotification('Encrypted CSV exported successfully', 'success');
            } catch (error) {
                console.error('Failed to export encrypted CSV:', error);
                showNotification('Failed to export encrypted CSV', 'error');
            }
        }

        async function importEncryptedCsv() {
            if (!state.isUnlocked) {
                showNotification('Vault is locked', 'error');
                return;
            }
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.vault';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    // Read file as ArrayBuffer
                    const arrayBuffer = await file.arrayBuffer();
                    
                    // Extract components from the file
                    const salt = new Uint8Array(arrayBuffer, 0, 16);
                    const iv = new Uint8Array(arrayBuffer, 16, 12);
                    const time = new Uint32Array(arrayBuffer, 28, 1)[0];
                    const memory = new Uint32Array(arrayBuffer, 32, 1)[0];
                    const parallelism = new Uint32Array(arrayBuffer, 36, 1)[0];
                    const ciphertext = new Uint8Array(arrayBuffer, 40);
                    
                    // Prompt for master password
                    const masterPassword = prompt('Enter the master password for this encrypted file:');
                    if (!masterPassword) return;
                    
                    // Derive key using Argon2id with the same parameters
                    const key = await deriveKeyArgon2(masterPassword, salt, time, memory, parallelism);
                    
                    // Decrypt the data
                    const decryptedData = await window.crypto.subtle.decrypt(
                        {
                            name: "AES-GCM",
                            iv: iv
                        },
                        key,
                        ciphertext
                    );
                    
                    // Convert to text
                    const decoder = new TextDecoder();
                    const csvText = decoder.decode(decryptedData);
                    
                    // Parse CSV
                    const entries = parseCsv(csvText);
                    
                    // Add imported entries to vault
                    state.vault.entries = [...state.vault.entries, ...entries];
                    
                    // Save to undo stack
                    state.undoStack.push(JSON.parse(JSON.stringify(state.vault.entries)));
                    
                    // Render entries
                    renderEntries();
                    
                    showNotification(`Imported ${entries.length} entries from encrypted CSV`, 'success');
                    
                    // Auto-save the vault
                    autoSaveVault();
                } catch (error) {
                    console.error('Failed to import encrypted CSV:', error);
                    showNotification('Failed to import encrypted CSV. Wrong password or corrupted file.', 'error');
                }
            };
            
            input.click();
        }

        // CSV parsing functions - UPDATED to handle commas in passwords
        function parseCsv(csvText) {
  const entries = [];
  let currentLine = '';
  let inQuotes = false;
  let quoteChar = '"';
  
  // First, properly parse the entire CSV text handling quoted newlines
  const lines = [];
  
  for (let i = 0; i < csvText.length; i++) {
    const char = csvText[i];
    
    if (char === quoteChar) {
      if (inQuotes && i + 1 < csvText.length && csvText[i + 1] === quoteChar) {
        // Escaped quote inside quoted field
        currentLine += quoteChar;
        i++; // Skip next quote
      } else {
        // Toggle quote state
        inQuotes = !inQuotes;
        currentLine += char;
      }
    } else if (char === '\n' || char === '\r') {
      if (inQuotes) {
        // Newline inside quotes - keep as part of field
        currentLine += char;
      } else {
        // Newline outside quotes - end of line
        if (currentLine.trim()) {
          lines.push(currentLine);
        }
        currentLine = '';
        // Skip \r in \r\n sequences
        if (char === '\r' && i + 1 < csvText.length && csvText[i + 1] === '\n') {
          i++;
        }
      }
    } else {
      currentLine += char;
    }
  }
  
  // Add the last line if any
  if (currentLine.trim()) {
    lines.push(currentLine);
  }
  
  if (lines.length === 0) return entries;

  // Parse header
  const headers = parseCsvLine(lines[0]).map(h => h.toLowerCase().trim());
  console.log('Headers:', headers);

  // Process data lines
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;

    const values = parseCsvLine(line);
    console.log('Values for line', i, ':', values);

    if (values.length >= 3) {
      const entry = {
        id: Date.now().toString() + i,
        name: '',
        username: '',
        password: '',
        url: '',
        email: '',
        totpSecret: null,
        notes: '',
        tags: [],
        createdAt: Date.now(),
        updatedAt: Date.now()
      };

      // Map based on header positions
      headers.forEach((header, index) => {
        if (index < values.length) {
          const value = values[index] || '';
          
          switch(header) {
            case 'name': entry.name = value; break;
            case 'username': entry.username = value; break;
            case 'password': entry.password = value; break;
            case 'url': entry.url = value; break;
            case 'email': entry.email = value; break;
            case 'totp secret': entry.totpSecret = value || null; break;
            case 'notes': entry.notes = value; break;
            case 'tags': 
              entry.tags = value ? value.split(';').map(t => t.trim()).filter(Boolean) : [];
              break;
          }
        }
      });

      console.log('Parsed entry:', entry);
      entries.push(entry);
    }
  }

  return entries;
}


        // Proper CSV line parser that handles quoted fields
function parseCsvLine(line) {
  const values = [];
  let current = '';
  let inQuotes = false;
  let quoteChar = '"';
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    
    if (char === quoteChar) {
      if (inQuotes && i + 1 < line.length && line[i + 1] === quoteChar) {
        // Escaped quote inside quoted field
        current += quoteChar;
        i++; // Skip next quote
      } else {
        // Toggle quote state
        inQuotes = !inQuotes;
      }
    } else if (char === ',' && !inQuotes) {
      // Comma outside quotes - field separator
      values.push(current);
      current = '';
    } else {
      // Regular character
      current += char;
    }
  }
  
  // Add the last field
  values.push(current);
  
  // Remove surrounding quotes and clean up
  return values.map(value => {
    // Remove surrounding quotes if present
    if (value.startsWith('"') && value.endsWith('"') && value.length > 1) {
      value = value.slice(1, -1);
    }
    // Replace escaped quotes
    value = value.replace(/""/g, '"');
    return value.trim();
  });
}

        function generateCsv(entries) {
  let csv = 'Name,Username,Password,URL,Email,TOTP Secret,Notes,Tags\n';
  
  entries.forEach(entry => {
    const fields = [
      escapeCsvField(entry.name),
      escapeCsvField(entry.username),
      escapeCsvField(entry.password),
      escapeCsvField(entry.url || ''),
      escapeCsvField(entry.email || ''),
      escapeCsvField(entry.totpSecret || ''),
      escapeCsvField(entry.notes),
      escapeCsvField((entry.tags || []).join(';'))
    ];
    
    csv += fields.join(',') + '\n';
  });
  
  return csv;
}

function escapeCsvField(field) {
  if (field === null || field === undefined) return '""';
  
  const stringField = String(field);
  
  // If field contains commas, quotes, newlines, or carriage returns, wrap in quotes
  if (stringField.includes(',') || 
      stringField.includes('"') || 
      stringField.includes('\n') || 
      stringField.includes('\r')) {
    return '"' + stringField.replace(/"/g, '""') + '"';
  }
  
  return stringField;
}

        // UPDATED: Argon2id key derivation function
        async function deriveKeyArgon2(password, salt, timeCost, memoryCost, parallelism) {
            try {
                // Convert salt to Uint8Array if it's not already
                const saltUint8 = salt instanceof Uint8Array ? salt : new Uint8Array(salt);
                
                // Hash the password using Argon2id
                const result = await argon2.hash({
                    pass: password,
                    salt: saltUint8,
                    time: timeCost,
                    mem: memoryCost,
                    parallelism: parallelism,
                    hashLen: 32,
                    type: argon2.ArgonType.Argon2id
                });
                
                // Import the derived hash as a CryptoKey for AES
                const key = await window.crypto.subtle.importKey(
                    'raw',
                    result.hash,
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt', 'decrypt']
                );
                
                return key;
            } catch (error) {
                console.error('Argon2 error:', error);
                throw new Error('Failed to derive key with Argon2');
            }
        }

        // UPDATED: Encrypt vault function with proper Argon2id
        async function encryptVault(data, password) {
            // Generate salt and IV
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            
            // Convert data to ArrayBuffer
            const encoder = new TextEncoder();
            const dataBuffer = encoder.encode(data);
            
            // Derive key using Argon2id
            const key = await deriveKeyArgon2(
                password, 
                salt, 
                state.vault.argon2Params.time, 
                state.vault.argon2Params.memory, 
                state.vault.argon2Params.parallelism
            );
            
            // Encrypt the data
            const encryptedData = await window.crypto.subtle.encrypt(
                {
                    name: "AES-GCM",
                    iv: iv
                },
                key,
                dataBuffer
            );
            
            // Create the file format: [salt][iv][time][memory][parallelism][ciphertext]
            const timeBytes = new Uint32Array([state.vault.argon2Params.time]);
            const memoryBytes = new Uint32Array([state.vault.argon2Params.memory]);
            const parallelismBytes = new Uint32Array([state.vault.argon2Params.parallelism]);
            
            const result = new Uint8Array(
                salt.length + 
                iv.length + 
                timeBytes.byteLength + 
                memoryBytes.byteLength + 
                parallelismBytes.byteLength + 
                encryptedData.byteLength
            );
            
            let offset = 0;
            result.set(salt, offset);
            offset += salt.length;
            result.set(iv, offset);
            offset += iv.length;
            result.set(new Uint8Array(timeBytes.buffer), offset);
            offset += timeBytes.byteLength;
            result.set(new Uint8Array(memoryBytes.buffer), offset);
            offset += memoryBytes.byteLength;
            result.set(new Uint8Array(parallelismBytes.buffer), offset);
            offset += parallelismBytes.byteLength;
            result.set(new Uint8Array(encryptedData), offset);
            
            return result;
        }

        // UPDATED: Decrypt vault function with proper Argon2id
        async function decryptVault(arrayBuffer, password, progressCallback = null) {
            // Extract components from the file
            const salt = new Uint8Array(arrayBuffer, 0, 16);
            const iv = new Uint8Array(arrayBuffer, 16, 12);
            const time = new Uint32Array(arrayBuffer, 28, 1)[0];
            const memory = new Uint32Array(arrayBuffer, 32, 1)[0];
            const parallelism = new Uint32Array(arrayBuffer, 36, 1)[0];
            const ciphertext = new Uint8Array(arrayBuffer, 40);
            
            if (progressCallback) progressCallback(0.3);
            
            // Derive key using Argon2 with the same parameters
            const key = await deriveKeyArgon2(password, salt, time, memory, parallelism);
            
            if (progressCallback) progressCallback(0.7);
            
            // Decrypt the data
            const decryptedData = await window.crypto.subtle.decrypt(
                {
                    name: "AES-GCM",
                    iv: iv
                },
                key,
                ciphertext
            );
            
            if (progressCallback) progressCallback(1.0);
            
            // Convert to text
            const decoder = new TextDecoder();
            return decoder.decode(decryptedData);
        }

        // Utility functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize the application
        init();
    </script>
</body>
</html>
